<html><body><meta http-equiv="content-type" content="text/html; charset=utf-8" /><p>
Рассмотрим ряд принципов, соблюдение которых необходимо при проектировании машин обработки знаний на основе предлагаемой технологии.</p>

<p>В указанной библиотеке можно выделить следующие разделы (частные библиотеки):</p>
<ul>
<li>Каждый разрабатываемый <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> должен быть по возможности предметно независим, т.е. во множество ключевых узлов данного <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i> не должны входить понятия, имеющие отношение непосредственно к рассматриваемой <i><sc_element sys_idtf = "subject_domain" > предметной области<sc_element></i>. Исключение составляют понятия из общих предметных областей, которые носят междисциплинарный характер (например, отношение <i><sc_element sys_idtf = "nrel_inclusion" > включение*<sc_element></i> или понятие <i><sc_element sys_idtf = "question" > действие<sc_element></i>). Данное правило может также быть нарушено в случае, если <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> является вспомогательным и ориентирован на обработку какого-либо конкретного класса объектов (например, <i><sc_element sys_idtf = "sc_agent" > sc-агенты<sc_element></i>, выполняющие арифметические вычисления могут напрямую работать с конкретными отношениями <i><sc_element sys_idtf = "nrel_sum" > сложение*<sc_element></i> и <i><sc_element sys_idtf = "nrel_multiplication" > произведение*<sc_element></i> и т.п.). Всю необходимую для решения задачи информацию <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> должен извлекать из семантической окрестности соответствующего инициированного действия. Очевидно, что <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i>, разработанный с учетом указанных требований, может быть использован при проектировании большего числа <i><sc_element sys_idtf = "ostis_system" > ostis-систем<sc_element></i>, чем в случае, если бы он был реализован с ориентацией на конкретную частную <i><sc_element sys_idtf = "subject_domain" > предметную область<sc_element></i>. После завершения разработки и отладки такой <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> должен быть включен в <i><sc_element sys_idtf = "library_of_reusable_abstract_sc_agents." > Библиотеку многократно используемых абстрактных sc-агентов<sc_element></i>.</li>
<li>Не стоит путать понятия <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> и агентная программа (в том числе – <i><sc_element sys_idtf = "agent_scp_program" > агентная scp-программа<sc_element></i>). Взаимодействие <i><sc_element sys_idtf = "sc_agent" > sc-агентов<sc_element></i> осуществляется исключительно через общую память, каждый <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> реагирует на появление в <i><sc_element sys_idtf = "sc_memory" > sc-памяти<sc_element></i> некоторой структуры. Таким образом, каждому <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> соответствует некоторое условие инициирования, и одна агентная программа, которая запускается автоматически при возникновении в <i><sc_element sys_idtf = "sc_memory" > sc-памяти<sc_element></i> соответствующего условия инициирования. При этом в рамках этой программы могут сколько угодно раз вызываться различные подпрограммы. Однако, не стоит путать инициирование sc-агента, которое осуществляется при появлении в sc-памяти соответствующей конструкции, и вызов подпрограммы другой программой, который предполагает явное указание вызываемой подпрограммы и перечня ее параметров.</li>

<li>При проектировании подпрограмм (в особенности – <i><sc_element sys_idtf = "agent_scp_program" > агентная scp-программа<sc_element></i>) следует учитывать возможность использования различными <i><sc_element sys_idtf = "sc_agent" > sc-агентами<sc_element></i> одних и тех подпрограмм. Таким образом, появляется необходимость говорить не только о  <i><sc_element sys_idtf = "library_of_reusable_abstract_sc_agents" > Библиотеке многократно используемых абстрактных sc-агентов<sc_element></i>, но и <i><sc_element sys_idtf = "library_of_reusable_abstract_sc_text" >Библиотеке многократно используемых программ обработки sc-текстов<sc_element></i> на различных языках программирования, в том числе <i><sc_element sys_idtf = "library_of_reusable_scp_programs" >Библиотеке многократно используемых scp-программ<sc_element></i>.</li>

<li>Каждый <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> должен самостоятельно проверять полноту соответствия своего условия инициирования текущему состоянию <i><sc_element sys_idtf = "sc_memory" > sc-памяти<sc_element></i>. В процессе решения какой-либо задачи может возникнуть ситуация, когда на появление одной и той же <i><sc_element sys_idtf = "structure" > структуры<sc_element></i> среагировали несколько <i><sc_element sys_idtf = "sc_agent" > sc-агентов<sc_element></i>. В таком случае выполнение продолжают только те из них, условие инициирования которых полностью соответствует сложившейся ситуации. Остальные <i><sc_element sys_idtf = "sc_agent" > sc-агенты<sc_element></i> в данном случае прекращают выполнение и возвращаются в режим ожидания.</li>

<li>Выполнение данного принципа достигается за счет тщательного уточнения спецификаций разрабатываемых <i><sc_element sys_idtf = "sc_agent" > sc-агентов<sc_element></i>. В общем случае условия инициирования у нескольких <i><sc_element sys_idtf = "sc_agent" > sc-агентов<sc_element></i> могут совпадать, однако такая ситуация является очень нежелательной и может быть реализована в том случае, если указанные sc-агенты не вносят существенных изменений в ту область памяти, с которой работают остальные <i><sc_element sys_idtf = "sc_agent" > sc-агенты<sc_element></i>.</li>

<li>При проектировании систем <i><sc_element sys_idtf = "sc_agent" > sc-агентов<sc_element></i> конкретной <i><sc_element sys_idtf = "ostis_system" > ostis-системы<sc_element></i> рекомендуется по возможности использовать <i><sc_element sys_idtf = "sc_agent" > sc-агентs<sc_element></i>, уже имеющиеся в Библиотеке многократно используемых абстрактных <i><sc_element sys_idtf = "sc_agent" > sc-агентов<sc_element></i>. Такой подход позволяет существенно сократить сроки проектирования конкретных <i><sc_element sys_idtf = "sc_model" > sс-моделей<sc_element></i> машин обработки знаний, а также минимизировать накладные расходы на отладку и верификацию используемых sc-агентов, поскольку все включенные в указанную библиотеку абстрактные <i><sc_element sys_idtf = "sc_agent" > sc-агенты<sc_element></i> уже прошли процедуру тщательной проверки. </li>

<li>При необходимости реализации нового <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i> следует руководствоваться следующими принципами выделения атомарных абстрактных <i><sc_element sys_idtf = "sc_agent" > sc-агентов<sc_element></i>:</li>
</ul>
<ul type="circle">
<li>проектируемый <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> должен быть максимально универсальным (как указано выше), что позволит в дальшейшем использовать его при разработке машин обработки знаний максимального возможного числа <i><sc_element sys_idtf = "ostis_system" > ostis-систем<sc_element></i>. При этом универсальность предполагает не только минимизацию числа ключевых узлов <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i>, но и выделение класса действий, выполняемых данным <i><sc_element sys_idtf = "sc_agent" > sc-агентом<sc_element></i> таким образом, чтобы имело смысл включить данный <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> в Библиотеку многократно используемых абстрактных <i><sc_element sys_idtf = "library_of_reusable_abstract_sc_agents
" >Библиотеку многократно используемых абстрактных sc-агентов<sc_element></i> и использовать его при разработке машин обработки знаний других <i><sc_element sys_idtf = "ostis_system" > ostis-систем<sc_element></i>. Не следует искусственно увязывать ряд действий в один sc-агент и наоборот, расчленять одно самодостаточное действие на поддействия. Это вызовет сложности восприятия принципов работы <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i> разработчиками и не позволит использовать <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> в ряде систем (например, в обучающих системах, которые должны объяснять ход решения пользователю);</li>

<li>акт деятельности каждого <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i> (выполняемое данным <i><sc_element sys_idtf = "sc_agent" > sc-агентом<sc_element></i> действие) должен быть логически целостным и завершенным. Следует помнить, что все <i><sc_element sys_idtf = "sc_agent" > sc-агенты<sc_element></i> взаимодействуют исключительно через общую память и избегать ситуаций, в которых инициирование одного <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i> осуществляется путем явной генерации известного условия инициирования другим <i><sc_element sys_idtf = "sc_agent" > sc-агентом<sc_element></i> (то есть по сути, явным непосредственным вызовом одного <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i> другим);</li>

<li>следует учитывать тот факт, что все <i><sc_element sys_idtf = "sc_agent" > sc-агенты<sc_element></i> работают параллельно, в связи с чем имеет смысл выделять в отдельные <i><sc_element sys_idtf = "sc_agent" > sc-агенты<sc_element></i> те относительно крупные фрагменты реализации некоторого общего алгоритма, которые могут выполняться независимо друг от друга;</li>

</ul>

<ul>

<li>Если в процессе работы <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i> генерирует в памяти какие-либо временные структуры, то при завершении работы он обязана удалять всю информацию, использование которой в системе более нецелесообразно (убрать за собой информационных «мусор»). Исключение составляют ситуации, когда подобная информация необходима нескольким <i><sc_element sys_idtf = "sc_agent" > sc-агентам<sc_element></i> для решения одной задачи, однако после решения задачи информация становится бесполезной или избыточной и требует удаления. В данном случае ни один из <i><sc_element sys_idtf = "sc_agent" > sc-агентов<sc_element></i> может оказаться не в состоянии удалить информационный мусор. В таком случае возникает необходимость говорить о специализированных <i><sc_element sys_idtf = "sc_agent" > sc-агентах<sc_element></i>, задачей которых является уничтожение информационного мусора</li>

<li>Часто <i><sc_element sys_idtf = "abstract_atomic_sc_agents" >атомарные абстрактные sc-агенты<sc_element></i> необходимо объединять в коллективы (<i><sc_element sys_idtf = "non_atomic_abstract_sc_agents" >неатомарные абстрактные sc-агенты<sc_element></i>) для решения сложных задач, т.е. таких задач, для решения которых недостаточно всего одного  <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i>. Очевидно, что под данное определение попадает большинство информационных задач из практически любой предметной области, которые не сводятся к простому информационному поиску.</li>


<li>При объединении <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i> в коллективы рекомендуется проектировать их таким образом, чтобы они могли быть использованы не только как часть рассматриваемого <i><sc_element sys_idtf = "non_atomic_abstract_sc_agents" >неатомарные абстрактные sc-агенты<sc_element></i>. В случае, если это не представляется возможным и некоторые <i><sc_element sys_idtf = "sc_agent" > sc-агены<sc_element></i>, будучи отделенными от коллектива, теряют смысл, необходимо указать данный факт при документировании рассматриваемых <i><sc_element sys_idtf = "sc_agent" > sc-агентов<sc_element></i>.</li>

<li>Фактическим инициатором запуска <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i> посредством общей памяти может бать как непосредственно пользователь системы, так и другой <i><sc_element sys_idtf = "sc_agent" > sc-агент<sc_element></i>. При этом это никак не должно отражаться в работе самого <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i>. Необходимость вывода (трансляции) какого-либо фрагмента базы знаний пользователю отслеживается специальными <i><sc_element sys_idtf = "sc_agent" > sc-агентами<sc_element></i> пользовательского интерфейса.</li>

<li>В качестве средств описания деятельности <i><sc_element sys_idtf = "sc_agent" > sc-агента<sc_element></i> над общей памятью используются <i><sc_element sys_idtf = "sc_lang" > sc-языки<sc_element></i>, соответствующие <i><sc_element sys_idtf = "section_subject_specialization_task_actions" > Предметной области действий и задач<sc_element></i>, а также <i><sc_element sys_idtf = "section_subject_domain_of_agents_over_sc_memory" > Предметной области абстрактных агентов, работающих над унифицированной семантической памятью<sc_element></i>.</li>

</ul>

<p>В процессе разработки системы <i><sc_element sys_idtf = "sc_agent" > sc-агенов<sc_element></i> можно выделить следующие этапы:</p>

<ul>

<li>определение необходимого набора <i><sc_element sys_idtf = "sc_agent" > sc-агенов<sc_element></i> (с учетом уже имеющихся в библиотеке);</li>

<li>уточнение набора ключевых узлов (в том числе – <i><sc_element sys_idtf = "actions_class" > классов действий<sc_element></i>), которые будут использоваться для синхронизации <i><sc_element sys_idtf = "sc_agent" > sc-агенов<sc_element></i> через общую память;</li>

<li>составление спецификаций каждого <i><sc_element sys_idtf = "sc_agent" > sc-агенa<sc_element></i>;</li>

<li>реализация и тестирование каждого sc-агента в отдельности;</li>

<li>реализация и тестирование коллектива <i><sc_element sys_idtf = "sc_agent" > sc-агенов<sc_element></i> как цельной подсистемы.</li>

</ul>

</body></html>
